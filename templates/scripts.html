<script>
  document.addEventListener('DOMContentLoaded', () => {
    console.log("DOM fully loaded");

    // Constants
    // ALLOWED_EXTENSIONS remain the same
    const ALLOWED_EXTENSIONS = ['.json', '.py', '.js', '.ts', '.sql', '.yml', '.svelte', '.md', '.tsx', '.yaml', '.tsx', '.css', '.html', '.sh', '.bat', '.txt', '.php', '.toml'];
    
    // Extension colors with better contrast
    function getExtensionColors() {
      return {
        'json': '#4A55A7',
        'py': '#306998',
        'js': '#F0DB4F',
        'ts': '#007ACC',
        'sql': '#E97B00',
        'yml': '#6C3483',
        'yaml': '#6C3483',
        'tsx': '#3178C6',
        'css': '#2965F1',
        'html': '#E34F26',
        'txt': '#5D6975',
        'toml': '#8D6E63',
        'md': '#6A737D',
        'sh': '#4CAF50',
        'bat': '#8BC34A',
        'php': '#777BB3',
        'svelte': '#FF3E00'
      };
    }
    
    const EXT_COLORS = getExtensionColors();

    // Grab references
    const githubModeDiv = document.getElementById('githubMode');
    const localModeDiv = document.getElementById('localMode');
    const progressContainerTop = document.getElementById('progressTop');
    const progressBarTop = document.getElementById('progressTopBar');
    const celebrationTop = document.getElementById('progressTopCelebration');
    const progressContainerBottom = document.getElementById('progressBottom');
    const progressBarBottom = document.getElementById('progressBottomBar');
    const celebrationBottom = document.getElementById('progressBottomCelebration');
    const groupingControls = document.getElementById('groupingControls');
    let currentTree = [];
    let isGithub = false;
    let basePath = '';
    let currentRepoId = null;

    function toggleMode(github) {
      console.log("Toggling mode to:", github ? "GitHub" : "Local");
      if (githubModeDiv && localModeDiv) {
        githubModeDiv.classList.toggle('hidden', !github);
        localModeDiv.classList.toggle('hidden', github);
        document.getElementById('githubTabBtn').classList.toggle('tab-active', github);
        document.getElementById('localTabBtn').classList.toggle('tab-active', !github);
      }
    }

    async function fetchData(endpoint, data, isGenerate = false) {
      console.log("Fetching data from:", endpoint, "with data:", data);
      const progressContainer = isGenerate ? progressContainerBottom : progressContainerTop;
      const progressBar = isGenerate ? progressBarBottom : progressBarTop;
      const celebration = isGenerate ? celebrationBottom : celebrationTop;

      if (progressContainer && progressBar && celebration) {
        progressContainer.classList.remove('hidden');
        progressBar.style.width = '0%';
      }

      try {
        // Show loading toast for longer operations
        if (isGenerate) {
          if (typeof showToast === 'function') {
            showToast("Generating output, please wait...", "info");
          }
        }
        
        const res = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        if (progressBar) progressBar.style.width = '100%';
        const result = await res.json();
        if (result.error) {
          console.error("API error:", result.error, { endpoint, data });
          
          // Enhanced error notification
          if (typeof Swal !== 'undefined') {
            Swal.fire({
              title: 'Error',
              text: result.error,
              icon: 'error',
              confirmButtonText: 'OK'
            });
          } else {
            alert(result.error);
          }
          
          throw new Error(result.error);
        }

        if (progressContainer && celebration) {
          celebration.classList.remove('hidden');
          
          // Show confetti for successful generation
          if (isGenerate && typeof showCelebration === 'function') {
            showCelebration(2000);
          }
          
          setTimeout(() => {
            celebration.classList.add('hidden');
            progressContainer.classList.add('hidden');
          }, 500);
        }

        console.log("Fetch successful:", result);
        return result;
      } catch (err) {
        console.error("Fetch error:", err.message, { endpoint, data });
        if (progressContainer) progressContainer.classList.add('hidden');
        
        // Enhanced error notification
        if (typeof Swal !== 'undefined') {
          Swal.fire({
            title: 'Error',
            text: err.message,
            icon: 'error',
            confirmButtonText: 'OK'
          });
        } else {
          alert("Error: " + err.message);
        }
        
        throw err;
      }
    }

    function showActionButtons() {
      console.log("Showing action buttons");
      const generateTextButton = document.getElementById('generateTextButton');
      const generateFullTextButton = document.getElementById('generateFullTextButton');
      const outputText = document.getElementById('outputText');
      const copyButton = document.getElementById('copyButton');
      const downloadButton = document.getElementById('downloadButton');
      
      if (generateTextButton && generateFullTextButton && outputText) {
        generateTextButton.classList.remove('hidden');
        generateFullTextButton.classList.remove('hidden');
        
        // Show tool tips for action buttons
        if (generateTextButton.getAttribute('data-tooltip') === null) {
          generateTextButton.setAttribute('data-tooltip', 'Generate output only for selected files');
          generateFullTextButton.setAttribute('data-tooltip', 'Generate output for all files but highlight selected ones');
        }
        
        // Initialize tooltips if they exist
        if (typeof tippy !== 'undefined' && typeof window.tippyInstances === 'undefined') {
          setTimeout(() => {
            if (typeof initTooltips === 'function') {
              initTooltips();
            }
          }, 100);
        }
        
        // Reset output area
        outputText.value = '';
        if (copyButton) copyButton.classList.add('hidden');
        if (downloadButton) downloadButton.classList.add('hidden');
      } else {
        console.error("Action button elements missing:", { generateTextButton, generateFullTextButton, outputText });
      }
    }

    function getSelectedFiles() {
      const selected = Array.from(document.querySelectorAll('#directoryStructure input[type="checkbox"]:checked:not(.folder-checkbox)'))
        .map(cb => JSON.parse(cb.value));
      console.log("Selected files:", selected);
      return selected;
    }

    // Function to load saved GitHub URLs
    async function loadSavedGithubRepos() {
      try {
        const result = await fetchData('/api/get-saved-paths', { type: 'github' });
        if (result.paths && result.paths.length > 0) {
          const dataList = document.getElementById('githubReposList');
          if (dataList) {
            dataList.innerHTML = '';
            result.paths.forEach(path => {
              const option = document.createElement('option');
              option.value = path;
              dataList.appendChild(option);
            });
          }
        }
      } catch (err) {
        console.error("Error loading saved GitHub repositories:", err);
      }
    }
    
    // Function to load saved local paths
    async function loadSavedLocalPaths() {
      try {
        const result = await fetchData('/api/get-saved-paths', { type: 'local' });
        if (result.paths && result.paths.length > 0) {
          const dataList = document.getElementById('localPathsList');
          if (dataList) {
            dataList.innerHTML = '';
            result.paths.forEach(path => {
              const option = document.createElement('option');
              option.value = path;
              dataList.appendChild(option);
            });
          }
        }
      } catch (err) {
        console.error("Error loading saved local paths:", err);
      }
    }
    
    // Apply a saved selection to the UI
    function applySelection(selectionData) {
      if (!selectionData) return;
      
      try {
        // Parse JSON if it's a string
        const selection = typeof selectionData === 'string' ? JSON.parse(selectionData) : selectionData;
        
        if (!Array.isArray(selection)) {
          console.error("Invalid selection format:", selection);
          return;
        }
        
        // Get all checkboxes
        const allCheckboxes = document.querySelectorAll('#directoryStructure input[type="checkbox"]');
        
        // First uncheck all
        allCheckboxes.forEach(cb => {
          cb.checked = false;
          cb.indeterminate = false;
        });
        
        // Then check the ones in the selection
        selection.forEach(path => {
          const cb = document.querySelector(`#directoryStructure input[type="checkbox"][data-path="${path}"]`);
          if (cb) {
            cb.checked = true;
            updateParentCheckbox(cb);
          }
        });
        
        updateExtensionBubbles();
        
        // Show toast with selection count
        if (typeof showToast === 'function') {
          showToast(`Loaded ${selection.length} file(s)`, 'success');
        }
      } catch (err) {
        console.error("Error applying selection:", err);
        
        if (typeof showToast === 'function') {
          showToast("Error applying selection", 'error');
        }
      }
    }

    function displayDirectoryStructure(tree, repoId, lastSelection) {
      console.log("Displaying directory structure with tree:", tree);
      // Store the repo ID 
      currentRepoId = repoId;
      
      const container = document.getElementById('directoryStructure');
      const extContainer = document.getElementById('extBubbleContainer');
      container.innerHTML = '';
      extContainer.innerHTML = '';
      if (!tree.length) {
        container.textContent = 'No files found.';
        return;
      }

      const filtered = tree.filter(item => ALLOWED_EXTENSIONS.some(ext => item.path.toLowerCase().endsWith(ext)));
      filtered.sort((a, b) => a.path.localeCompare(b.path));

      const directoryStructure = {};
      const extensionMap = new Map();

      filtered.forEach(item => {
        const pathParts = item.path.split('/').filter(part => part);
        let currentLevel = directoryStructure;
        pathParts.forEach((part, index) => {
          if (!currentLevel[part]) {
            currentLevel[part] = (index === pathParts.length - 1) ? item : {};
          }
          currentLevel = currentLevel[part];
        });

        const ext = item.path.split('.').pop().toLowerCase();
        if (!extensionMap.has(ext)) {
          extensionMap.set(ext, []);
        }
        extensionMap.get(ext).push(item);
      });

      const rootUl = document.createElement('ul');
      rootUl.classList.add('tree-lines');
      container.appendChild(rootUl);

      function createTreeNode(name, item, parentUl, depth = 0) {
        const li = document.createElement('li');
        li.className = 'relative';
        li.style.marginLeft = `${depth * 1}rem`;
        parentUl.appendChild(li);

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'checkbox checkbox-sm mr-2';

        if (typeof item === 'object' && !item.path) {
          // Folder node
          const details = document.createElement('details');
          details.open = true;
          const summary = document.createElement('summary');
          summary.className = 'folder-node font-bold flex items-center';
          
          // Add folder icon and name
          summary.innerHTML = `<span class="ml-1 code-folder">${name}</span>`;
          details.appendChild(summary);
          li.appendChild(details);

          const ul = document.createElement('ul');
          ul.classList.add('tree-lines');
          details.appendChild(ul);

          checkbox.classList.add('folder-checkbox');
          li.insertBefore(checkbox, details);

          for (const [childName, childItem] of Object.entries(item)) {
            createTreeNode(childName, childItem, ul, depth + 1);
          }

          checkbox.addEventListener('change', () => {
            const childCheckboxes = li.querySelectorAll('input[type="checkbox"]');
            childCheckboxes.forEach(cb => {
              cb.checked = checkbox.checked;
              cb.indeterminate = false;
            });
            updateParentCheckbox(checkbox);
            updateExtensionBubbles();
          });
        } else {
          // File node
          checkbox.value = JSON.stringify(item);
          checkbox.dataset.path = item.path;
          li.appendChild(checkbox);
          
          // Get icon class based on extension
          const ext = name.split('.').pop().toLowerCase();
          const iconClass = `file-${ext}`;
          
          // Create a span with the file name and icon class
          const fileNameSpan = document.createElement('span');
          fileNameSpan.className = `code-file ${iconClass}`;
          fileNameSpan.textContent = ` ${name}`;
          li.appendChild(fileNameSpan);

          extensionMap.get(ext)?.forEach(file => {
            if (file.path === item.path) {
              file.checkbox = checkbox;
            }
          });
        }

        checkbox.addEventListener('change', () => {
          updateParentCheckbox(checkbox);
          updateExtensionBubbles();
        });
      }

      for (const [name, item] of Object.entries(directoryStructure)) {
        createTreeNode(name, item, rootUl);
      }

      // "All" bubble
      const allBubble = document.createElement('span');
      allBubble.className = 'ext-bubble selected';
      allBubble.style.backgroundColor = '#555';  
      allBubble.style.color = '#fff';  
      allBubble.id = 'allBubble';
      allBubble.innerHTML = `<i class="fa-solid fa-check-double mr-1"></i> All (${filtered.length})`;
      allBubble.addEventListener('click', () => {
        const isSelected = !allBubble.classList.contains('selected');
        allBubble.classList.toggle('selected', isSelected);
        extContainer.querySelectorAll('.ext-bubble:not(#allBubble)').forEach(bubble => {
          bubble.classList.toggle('selected', isSelected);
          const ext = bubble.dataset.ext;
          extensionMap.get(ext)?.forEach(file => {
            if (file.checkbox) {
              file.checkbox.checked = isSelected;
              updateParentCheckbox(file.checkbox);
            }
          });
        });
      });
      extContainer.appendChild(allBubble);

      // Individual extension bubbles
      extensionMap.forEach((files, ext) => {
        const bubble = document.createElement('span');
        bubble.className = 'ext-bubble selected';
        bubble.style.backgroundColor = EXT_COLORS[ext] || '#555';
        bubble.style.color = '#fff';
        
        // Add file icon based on extension
        const extension = ext.toLowerCase();
        let icon = 'fa-file-code';
        if (extension === 'md' || extension === 'txt') icon = 'fa-file-alt';
        if (extension === 'json' || extension === 'yaml' || extension === 'yml') icon = 'fa-file-alt';
        if (extension === 'html') icon = 'fa-file-code';
        if (extension === 'css') icon = 'fa-file-code';
        if (extension === 'js') icon = 'fa-file-code';
        if (extension === 'py') icon = 'fa-file-code';
        
        bubble.innerHTML = `<i class="fa-solid ${icon} mr-1"></i> .${ext} (${files.length})`;
        bubble.dataset.ext = ext;
        bubble.addEventListener('click', () => {
          const isSelected = !bubble.classList.contains('selected');
          bubble.classList.toggle('selected', isSelected);
          files.forEach(file => {
            if (file.checkbox) {
              file.checkbox.checked = isSelected;
              updateParentCheckbox(file.checkbox);
            }
          });
          updateAllBubble();
        });
        extContainer.appendChild(bubble);
      });

      function updateAllBubble() {
        const allSelected = Array.from(extContainer.querySelectorAll('.ext-bubble:not(#allBubble)'))
          .every(bubble => bubble.classList.contains('selected'));
        allBubble.classList.toggle('selected', allSelected);
      }

      const lineHeight = 24;
      const padding = 32;
      const totalHeight = (filtered.length * lineHeight) + padding;
      container.style.height = `${Math.max(768, totalHeight)}px`;

      container.addEventListener('change', (e) => {
        if (e.target.type === 'checkbox' && !e.target.classList.contains('folder-checkbox')) {
          updateParentCheckbox(e.target);
          updateExtensionBubbles();
        }
      });

      updateExtensionBubbles();
      
      // Make sortable extension bubbles
      if (typeof Sortable !== 'undefined') {
        new Sortable(extContainer, {
          animation: 150,
          ghostClass: 'sorting-ghost',
          onEnd: function(evt) {
            // Optional: Save the new ordering to localStorage
            const newOrder = Array.from(extContainer.children).map(el => 
              el.id === 'allBubble' ? 'all' : el.dataset.ext
            );
            localStorage.setItem('extensionOrder', JSON.stringify(newOrder));
          }
        });
      }
    }

    function updateParentCheckbox(checkbox) {
      const li = checkbox.closest('li');
      if (!li) return;
      const parentLi = li.parentElement.closest('li');
      if (!parentLi) return;
      const parentCheckbox = parentLi.querySelector(':scope > input[type="checkbox"]');
      if (!parentCheckbox) return;

      const siblingCheckboxes = parentLi.querySelectorAll(':scope > ul input[type="checkbox"]');
      const checkedCount = Array.from(siblingCheckboxes).filter(cb => cb.checked).length;
      const totalCount = siblingCheckboxes.length;

      if (checkedCount === 0) {
        parentCheckbox.checked = false;
        parentCheckbox.indeterminate = false;
      } else if (checkedCount === totalCount) {
        parentCheckbox.checked = true;
        parentCheckbox.indeterminate = false;
      } else {
        parentCheckbox.checked = false;
        parentCheckbox.indeterminate = true;
      }
      updateParentCheckbox(parentCheckbox);
    }

    function updateExtensionBubbles() {
      const extContainer = document.getElementById('extBubbleContainer');
      const selectedFiles = getSelectedFiles();
      const selectedExts = new Set(selectedFiles.map(file => file.path.split('.').pop().toLowerCase()));
      extContainer.querySelectorAll('.ext-bubble:not(#allBubble)').forEach(bubble => {
        const ext = bubble.dataset.ext;
        bubble.classList.toggle('selected', selectedExts.has(ext));
      });
      const allBubble = document.getElementById('allBubble');
      if (allBubble) {
        const allSelected = Array.from(extContainer.querySelectorAll('.ext-bubble:not(#allBubble)'))
          .every(bubble => bubble.classList.contains('selected'));
        allBubble.classList.toggle('selected', allSelected);
      }
    }
    
    // Save the current file selection to the database
    async function saveCurrentSelection() {
      const selectedFiles = getSelectedFiles();
      const selection = selectedFiles.map(f => f.path);
      
      try {
        await fetchData('/api/save-selection', {
          repoId: currentRepoId,
          selection: selection
        });
        console.log("Selection saved to database");
      } catch (err) {
        console.error("Error saving selection:", err);
      }
    }

    function formatRepoContents(contents, selected) {
      contents.sort((a, b) => a.path.localeCompare(b.path));
      let output = '# Repository Content\n\n';
      output += '## Directory Structure (Selected Files)\n\n';
      output += contents.map(c => `├── ${c.path}`).join('\n');
      
      output += '\n\n## Files\n';
      output += contents.map(c => `\n### File: ${c.path}\n\`\`\`${getLanguageFromPath(c.path)}\n${c.text}\n\`\`\``).join('\n');

      try {
        if (typeof GPTTokenizer_cl100k_base !== 'undefined') {
          const tokens = GPTTokenizer_cl100k_base.encode(output).length;
          updateTokenCount(output);
        }
      } catch (err) {
        console.error("Token count error or tokenizer not loaded:", err);
      }
      return output;
    }
    
    function getLanguageFromPath(path) {
      const ext = path.split('.').pop().toLowerCase();
      const langMap = {
        'js': 'javascript',
        'ts': 'typescript',
        'py': 'python',
        'html': 'html',
        'css': 'css',
        'json': 'json',
        'md': 'markdown',
        'sql': 'sql',
        'yml': 'yaml',
        'yaml': 'yaml',
        'sh': 'bash',
        'bat': 'batch',
        'php': 'php',
        'toml': 'toml',
        'svelte': 'svelte'
      };
      return langMap[ext] || '';
    }
    
    // Original placeholder for token counting
    window.updateTokenCount = function(text) {
      try {
        if (typeof GPTTokenizer_cl100k_base !== 'undefined') {
          const tokens = GPTTokenizer_cl100k_base.encode(text).length;
          document.getElementById('tokenCount').textContent = `${tokens.toLocaleString()}`;
          
          // Update token progress visualization
          updateTokenDisplay(tokens);
        }
      } catch (err) {
        console.error("Token count error or tokenizer not loaded:", err);
      }
    };
    
    // Token display with progress visualization
    function updateTokenDisplay(count) {
      const tokenCount = document.getElementById('tokenCount');
      const tokenBar = document.getElementById('tokenProgressBar');
      const tokenPercentage = document.getElementById('tokenPercentage');
      const tokenContainer = document.querySelector('.token-usage-container');
      
      if (!tokenCount || !tokenBar || !tokenPercentage || !tokenContainer) return;
      
      tokenContainer.classList.remove('hidden');
      tokenCount.textContent = `${count.toLocaleString()} tokens`;
      
      const maxTokens = 4000;
      const percentage = Math.min(100, (count / maxTokens) * 100);
      
      tokenBar.style.width = `${percentage}%`;
      tokenPercentage.textContent = `${Math.round(percentage)}%`;
      
      if (percentage > 90) {
        tokenBar.className = 'bg-error rounded-full h-1.5';
        // Show warning if over 90%
        if (typeof showToast === 'function') {
          showToast(`Warning: Token count is at ${Math.round(percentage)}% of typical LLM limit`, 'warning');
        }
      } else if (percentage > 70) {
        tokenBar.className = 'bg-warning rounded-full h-1.5';
      } else {
        tokenBar.className = 'bg-primary rounded-full h-1.5';
      }
    }

    function formatFullRepoContents(contents, selected) {
      contents.sort((a, b) => a.path.localeCompare(b.path));
      const selectedPaths = new Set(selected.map(f => f.path));

      let output = '# Complete Repository Overview\n\n';
      output += '## Full Directory Structure\n\n';
      output += contents.map(c => `${selectedPaths.has(c.path) ? '├──' : '└──'} ${c.path}`).join('\n');

      output += '\n\n## Selected Files\n';
      output += contents
        .filter(c => selectedPaths.has(c.path))
        .map(c => `\n### File: ${c.path}\n\`\`\`${getLanguageFromPath(c.path)}\n${c.text}\n\`\`\``)
        .join('\n');

      try {
        if (typeof GPTTokenizer_cl100k_base !== 'undefined') {
          updateTokenCount(output);
        }
      } catch (err) {
        console.error("Token count error or tokenizer not loaded:", err);
      }
      return output;
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      
      // Show toast notification
      if (typeof showToast === 'function') {
        showToast(`Downloaded ${filename}`, 'success');
      }
    }

    let groupings = [];

    async function loadGroupings() {
      try {
        const result = await fetchData('/api/get-groupings', { repoIdentifier: basePath });
        groupings = result.groupings;
        const select = document.getElementById('groupingSelect');
        select.innerHTML = '<option value="">Select a saved grouping</option>';
        groupings.forEach(g => {
          const option = document.createElement('option');
          option.value = g.name;
          option.textContent = g.name;
          select.appendChild(option);
        });
      } catch (err) {
        if (typeof showToast === 'function') {
          showToast("Error loading groupings: " + err.message, 'error');
        } else {
          alert("Error loading groupings: " + err.message);
        }
      }
    }

    // Event listeners for mode toggles
    const githubTabBtn = document.getElementById('githubTabBtn');
    const localTabBtn = document.getElementById('localTabBtn');
    if (githubTabBtn) {
      githubTabBtn.addEventListener('click', () => {
        toggleMode(true);
        loadSavedGithubRepos(); // Load saved GitHub repos when switching to GitHub mode
      });
    }
    if (localTabBtn) {
      localTabBtn.addEventListener('click', () => {
        toggleMode(false);
        loadSavedLocalPaths(); // Load saved local paths when switching to local mode
      });
    }

    // Load saved paths when the page loads
    loadSavedGithubRepos();
    loadSavedLocalPaths();

    // Fetch GitHub or Local
    const fetchGitHubBtn = document.getElementById('fetchGitHub');
    if (fetchGitHubBtn) {
      fetchGitHubBtn.addEventListener('click', async () => {
        const repoUrl = document.getElementById('repoUrl')?.value.trim();
        if (!repoUrl) {
          if (typeof showToast === 'function') {
            showToast("Please enter a GitHub URL", 'error');
          } else {
            alert("Enter a GitHub URL.");
          }
          return;
        }
        isGithub = true;
        basePath = repoUrl;
        try {
          const data = { repoUrl };
          {% if not has_github_token %}data.accessToken = document.getElementById('accessToken')?.value.trim();{% endif %}
          
          if (typeof showToast === 'function') {
            showToast("Fetching repository data...", 'info');
          }
          
          const result = await fetchData('/api/github-tree', data);
          currentTree = result.tree;
          currentRepoId = result.repoId;
          displayDirectoryStructure(currentTree, currentRepoId, null);
          showActionButtons();
          
          // Show success toast
          if (typeof showToast === 'function') {
            showToast(`Fetched ${result.tree.length} files from GitHub repository`, 'success');
          }
        } catch (err) {
          if (typeof showToast === 'function') {
            showToast("Error: " + err.message, 'error');
          } else {
            alert("Error: " + err.message);
          }
        }
      });
    }

    const fetchLocalBtn = document.getElementById('fetchLocal');
    if (fetchLocalBtn) {
      fetchLocalBtn.addEventListener('click', async () => {
        const localPath = document.getElementById('localPath')?.value.trim();
        if (!localPath) {
          if (typeof showToast === 'function') {
            showToast("Please enter a local file path", 'error');
          } else {
            alert("Enter a local path.");
          }
          return;
        }
        isGithub = false;
        basePath = localPath;
        try {
          if (typeof showToast === 'function') {
            showToast("Scanning local directory...", 'info');
          }
          
          const result = await fetchData('/api/local-tree', { localPath });
          currentTree = result.tree;
          currentRepoId = result.repoId;
          displayDirectoryStructure(currentTree, currentRepoId, null);
          showActionButtons();
          
          // Show success toast
          if (typeof showToast === 'function') {
            showToast(`Scanned ${result.tree.length} files from local directory`, 'success');
          }
        } catch (err) {
          if (typeof showToast === 'function') {
            showToast("Error: " + err.message, 'error');
          } else {
            alert("Error: " + err.message);
          }
        }
      });
    }

    // Generate text from selected files
    document.getElementById('generateTextButton').addEventListener('click', async () => {
      const selected = getSelectedFiles();
      if (!selected.length) {
        if (typeof showToast === 'function') {
          showToast("Please select at least one file", 'warning');
        } else {
          alert("No files selected.");
        }
        return;
      }
      
      const data = { repoIdentifier: basePath, filePaths: selected.map(f => f.path) };
      {% if not has_github_token %} if (isGithub) data.accessToken = document.getElementById('accessToken')?.value.trim(); {% endif %}
      
      try {
        if (typeof showToast === 'function') {
          showToast(`Generating output for ${selected.length} selected files...`, 'info');
        }
        
        const contents = await fetchData('/api/file-contents', data, true);
        const outputText = document.getElementById('outputText');
        outputText.value = formatRepoContents(contents, selected);
        document.getElementById('copyButton').classList.remove('hidden');
        document.getElementById('downloadButton').classList.remove('hidden');
        
        // Hide the empty state overlay
        const emptyStateOverlay = document.getElementById('emptyStateOverlay');
        if (emptyStateOverlay) {
          emptyStateOverlay.style.opacity = '0';
        }
        
        // Show success message and celebrate
        if (typeof showToast === 'function') {
          showToast("Output generated successfully!", 'success');
        }
        
        if (typeof showCelebration === 'function') {
          showCelebration(1500);
        }
      } catch (err) {
        if (typeof showToast === 'function') {
          showToast("Error: " + err.message, 'error');
        } else {
          alert("Error: " + err.message);
        }
      }
    });

    // Generate text for *all* files, marking selected separately
    document.getElementById('generateFullTextButton').addEventListener('click', async () => {
      const selected = getSelectedFiles();
      if (!selected.length) {
        if (typeof showToast === 'function') {
          showToast("Please select at least one file to highlight", 'warning');
        }
      }
      
      const allFilePaths = currentTree.filter(f => ALLOWED_EXTENSIONS.some(ext => f.path.toLowerCase().endsWith(ext))).map(f => f.path);
      const data = { repoIdentifier: basePath, filePaths: allFilePaths };
      {% if not has_github_token %} if (isGithub) data.accessToken = document.getElementById('accessToken')?.value.trim(); {% endif %}
      
      try {
        if (typeof showToast === 'function') {
          showToast(`Generating full project output (${allFilePaths.length} files)...`, 'info');
        }
        
        // Use a try-catch with a timeout to handle potential server timeouts
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error("Request timed out. The project might be too large to process at once.")), 60000);
        });
        
        const contents = await Promise.race([
          fetchData('/api/file-contents', data, true),
          timeoutPromise
        ]);
        
        const outputText = document.getElementById('outputText');
        outputText.value = formatFullRepoContents(contents, selected);
        document.getElementById('copyButton').classList.remove('hidden');
        document.getElementById('downloadButton').classList.remove('hidden');
        
        // Hide the empty state overlay
        const emptyStateOverlay = document.getElementById('emptyStateOverlay');
        if (emptyStateOverlay) {
          emptyStateOverlay.style.opacity = '0';
        }
        
        // Show success message
        if (typeof showToast === 'function') {
          showToast("Full project output generated!", 'success');
        }
        
        if (typeof showCelebration === 'function') {
          showCelebration(1500);
        }
      } catch (err) {
        if (typeof showToast === 'function') {
          showToast("Error: " + err.message, 'error');
        } else {
          alert("Error: " + err.message);
        }
        
        // Clear any existing progress indicators
        if (progressContainerBottom) {
          progressContainerBottom.classList.add('hidden');
        }
      }
    });

    // Copy to clipboard
    document.getElementById('copyButton').addEventListener('click', () => {
      const text = document.getElementById('outputText').value;
      navigator.clipboard.writeText(text).then(() => {
        if (typeof showToast === 'function') {
          showToast("Copied to clipboard!", 'success');
        } else {
          const toast = document.createElement('div');
          toast.className = 'toast toast-end';
          toast.innerHTML = `
            <div class="alert alert-success">
              <i class="fa-solid fa-check-circle"></i>
              <span>Copied to clipboard!</span>
            </div>
          `;
          document.body.appendChild(toast);
          setTimeout(() => {
            toast.remove();
          }, 2000);
        }
      });
    });

    // Download
    document.getElementById('downloadButton').addEventListener('click', () => {
      const text = document.getElementById('outputText').value;
      if (!text.trim()) {
        if (typeof showToast === 'function') {
          showToast("No content to download", 'warning');
        } else {
          alert("No content to download.");
        }
        return;
      }
      
      // Get current timestamp for filename
      const now = new Date();
      const timestamp = `${now.getFullYear()}-${(now.getMonth()+1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}-${now.getMinutes().toString().padStart(2, '0')}`;
      
      downloadBlob(new Blob([text], { type: 'text/plain' }), `code_export_${timestamp}.md`);
    });

    // Groupings
    document.getElementById('saveGrouping').addEventListener('click', async () => {
      const groupingName = document.getElementById('groupingName').value.trim();
      const selected = getSelectedFiles();
      
      if (!groupingName) {
        if (typeof showToast === 'function') {
          showToast("Please enter a grouping name", 'warning');
        } else {
          alert("Enter a grouping name.");
        }
        return;
      }
      
      if (!selected.length) {
        if (typeof showToast === 'function') {
          showToast("Please select files to save in this grouping", 'warning');
        } else {
          alert("No files selected to save in grouping.");
        }
        return;
      }
      
      const data = { repoIdentifier: basePath, groupingName, filePaths: selected.map(f => f.path) };
      
      try {
        const result = await fetchData('/api/save-grouping', data);
        
        if (typeof showToast === 'function') {
          showToast(`Grouping "${groupingName}" saved with ${selected.length} files`, 'success');
        } else {
          alert(result.message);
        }
        
        await loadGroupings();
        
        // Clear the grouping name input after saving
        document.getElementById('groupingName').value = '';
      } catch (err) {
        if (typeof showToast === 'function') {
          showToast("Error saving grouping: " + err.message, 'error');
        } else {
          alert("Error saving grouping: " + err.message);
        }
      }
    });

    document.getElementById('loadGrouping').addEventListener('click', () => {
      const selectedName = document.getElementById('groupingSelect').value;
      if (!selectedName) {
        if (typeof showToast === 'function') {
          showToast("Please select a grouping to load", 'warning');
        } else {
          alert("Please select a grouping to load.");
        }
        return;
      }

      const allCheckboxes = document.querySelectorAll('#directoryStructure input[type="checkbox"]');
      allCheckboxes.forEach(cb => {
        cb.checked = false;
        cb.indeterminate = false;
      });

      const grouping = groupings.find(g => g.name === selectedName);
      if (grouping && grouping.files.length) {
        grouping.files.forEach(file => {
          const cb = document.querySelector(`#directoryStructure input[type="checkbox"][data-path="${file.path}"]`);
          if (cb) {
            cb.checked = true;
            updateParentCheckbox(cb);
          }
        });
        updateExtensionBubbles();
        
        if (typeof showToast === 'function') {
          showToast(`Loaded grouping "${selectedName}" with ${grouping.files.length} files`, 'success');
        }
      } else {
        if (typeof showToast === 'function') {
          showToast("No files found in this grouping", 'error');
        } else {
          alert("No files found in this grouping or grouping not loaded correctly.");
        }
      }
    });
    
    // Attach data-tooltip attributes to various elements for tooltips
    function setupTooltips() {
      const tooltipData = [
        { selector: '#expandAllBtn', tooltip: 'Expand all folders' },
        { selector: '#collapseAllBtn', tooltip: 'Collapse all folders' },
        { selector: '#clearSearchBtn', tooltip: 'Clear search' },
        { selector: '#treeSearchInput', tooltip: 'Search files by name' },
        { selector: '#saveGrouping', tooltip: 'Save current selection as a named grouping' },
        { selector: '#loadGrouping', tooltip: 'Load a saved selection grouping' },
        { selector: '#expandButton', tooltip: 'Toggle fullscreen view' },
        { selector: '#copyButton', tooltip: 'Copy output to clipboard' },
        { selector: '#downloadButton', tooltip: 'Download output as file' },
        { selector: '#allBubble', tooltip: 'Select or deselect all file types' }
      ];
      
      tooltipData.forEach(item => {
        const element = document.querySelector(item.selector);
        if (element && !element.hasAttribute('data-tooltip')) {
          element.setAttribute('data-tooltip', item.tooltip);
        }
      });
    }
    
    // Initialize tooltips when DOM is loaded
    setTimeout(setupTooltips, 500);
  });
</script>
<script src="https://unpkg.com/gpt-tokenizer"></script>