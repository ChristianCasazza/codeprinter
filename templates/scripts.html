<script>
  document.addEventListener('DOMContentLoaded', () => {
    console.log("DOM fully loaded");

    // Dynamic file formats - will be loaded from the API
    let ALLOWED_EXTENSIONS = [];
    let EXT_COLORS = {};
    let FILE_LANGUAGES = {};
    
    // Function to fetch file formats from the API
    async function loadFileFormats() {
      try {
        const response = await fetch('/api/file-formats');
        const result = await response.json();
        
        // Update global variables with fetched formats
        ALLOWED_EXTENSIONS = result.extensions;
        EXT_COLORS = Object.entries(result.colors).reduce((acc, [ext, color]) => {
          acc[ext] = color;
          return acc;
        }, {});
        FILE_LANGUAGES = result.languages;
        
        // Store pattern formats separately for pattern matching
        window.FILE_PATTERNS = result.patterns || [];
        
        console.log("Loaded file formats:", { 
          extensions: ALLOWED_EXTENSIONS.length, 
          colors: Object.keys(EXT_COLORS).length 
        });
        
        // If file formats were modified, update the UI if tree is already loaded
        if (currentTree && currentTree.length > 0) {
          displayDirectoryStructure(currentTree, currentRepoId);
        }
        
        // Initialize any file format management UI
        if (window.formatUIFunctions && typeof window.formatUIFunctions.updateTable === 'function') {
          window.formatUIFunctions.updateTable(result.formats);
        } else {
          // Will use the placeholder function until extension_filters.html loads
          window.updateFormatSettingsUI(result.formats);
        }
      } catch (error) {
        console.error("Error loading file formats:", error);
        // Fallback to default formats if API fails
        setDefaultFormats();
        if (typeof showToast === 'function') {
          showToast("Error loading file formats. Using defaults.", 'error');
        }
      }
    }
    
    // Fallback to defaults if API fails
    function setDefaultFormats() {
      ALLOWED_EXTENSIONS = ['.json', '.py', '.tpl', '.js', '.ts', '.sql', '.yml', '.svelte', '.md', '.tsx', '.yaml', '.tsx', '.css', '.html', '.sh', '.bat', '.txt', '.php', '.toml'];
      
      EXT_COLORS = {
        'json': '#4A55A7',
        'py': '#306998',
        'js': '#F0DB4F',
        'ts': '#007ACC',
        'sql': '#E97B00',
        'yml': '#6C3483',
        'yaml': '#6C3483',
        'tsx': '#3178C6',
        'css': '#2965F1',
        'html': '#E34F26',
        'txt': '#5D6975',
        'toml': '#8D6E63',
        'md': '#6A737D',
        'sh': '#4CAF50',
        'bat': '#8BC34A',
        'php': '#777BB3',
        'svelte': '#FF3E00',
        'tpl': '#1C86EE'
      };
      
      FILE_LANGUAGES = {
        'js': 'javascript',
        'ts': 'typescript',
        'py': 'python',
        'html': 'html',
        'css': 'css',
        'json': 'json',
        'md': 'markdown',
        'sql': 'sql',
        'yml': 'yaml',
        'yaml': 'yaml',
        'sh': 'bash',
        'bat': 'batch',
        'php': 'php',
        'toml': 'toml',
        'svelte': 'svelte',
        'tpl': 'html'
      };
      
      // Default patterns
      window.FILE_PATTERNS = [
        {
          extension: 'Dockerfile*',
          color: '#2496ED',
          language: 'dockerfile',  // Used by syntax highlighters
          enabled: 1,
          is_pattern: 1
        }
      ];
    }
    
    // Load file formats when the page loads
    loadFileFormats();
    
    // Function to update the file format manager UI (defined in extension_filters.html)
    window.updateFormatSettingsUI = function(formats) {
      // This function is implemented in extension_filters.html
      // We define it here as a placeholder to avoid errors if the function is called before it's defined
      console.log("updateFormatSettingsUI called with", formats ? formats.length : 0, "formats");
      
      // If we have a reference to the actual function in the window object, call it directly
      if (window.formatUIFunctions && typeof window.formatUIFunctions.updateTable === 'function') {
        window.formatUIFunctions.updateTable(formats);
      }
    };

    // Grab references
    const githubModeDiv = document.getElementById('githubMode');
    const localModeDiv = document.getElementById('localMode');
    const progressContainerTop = document.getElementById('progressTop');
    const progressBarTop = document.getElementById('progressTopBar');
    const celebrationTop = document.getElementById('progressTopCelebration');
    const progressContainerBottom = document.getElementById('progressBottom');
    const progressBarBottom = document.getElementById('progressBottomBar');
    const celebrationBottom = document.getElementById('progressBottomCelebration');
    const groupingControls = document.getElementById('groupingControls');
    let currentTree = [];
    let isGithub = false;
    let basePath = '';
    let currentRepoId = null;

    function toggleMode(github) {
      console.log("Toggling mode to:", github ? "GitHub" : "Local");
      if (githubModeDiv && localModeDiv) {
        githubModeDiv.classList.toggle('hidden', !github);
        localModeDiv.classList.toggle('hidden', github);
        document.getElementById('githubTabBtn').classList.toggle('tab-active', github);
        document.getElementById('localTabBtn').classList.toggle('tab-active', !github);
      }
    }

    async function fetchData(endpoint, data, isGenerate = false) {
      console.log("Fetching data from:", endpoint, "with data:", data);
      const progressContainer = isGenerate ? progressContainerBottom : progressContainerTop;
      const progressBar = isGenerate ? progressBarBottom : progressBarTop;
      const celebration = isGenerate ? celebrationBottom : celebrationTop;

      if (progressContainer && progressBar && celebration) {
        progressContainer.classList.remove('hidden');
        progressBar.style.width = '0%';
      }

      try {
        // Show loading toast for longer operations
        if (isGenerate) {
          if (typeof showToast === 'function') {
            showToast("Generating output, please wait...", "info");
          }
        }
        
        const res = await fetch(endpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        if (progressBar) progressBar.style.width = '100%';
        const result = await res.json();
        if (result.error) {
          console.error("API error:", result.error, { endpoint, data });
          
          // Enhanced error notification
          if (typeof Swal !== 'undefined') {
            Swal.fire({
              title: 'Error',
              text: result.error,
              icon: 'error',
              confirmButtonText: 'OK'
            });
          } else {
            alert(result.error);
          }
          
          throw new Error(result.error);
        }

        if (progressContainer && celebration) {
          celebration.classList.remove('hidden');
          
          // Show confetti for successful generation
          if (isGenerate && typeof showCelebration === 'function') {
            showCelebration(2000);
          }
          
          setTimeout(() => {
            celebration.classList.add('hidden');
            progressContainer.classList.add('hidden');
          }, 500);
        }

        console.log("Fetch successful:", result);
        return result;
      } catch (err) {
        console.error("Fetch error:", err.message, { endpoint, data });
        if (progressContainer) progressContainer.classList.add('hidden');
        
        // Enhanced error notification
        if (typeof Swal !== 'undefined') {
          Swal.fire({
            title: 'Error',
            text: err.message,
            icon: 'error',
            confirmButtonText: 'OK'
          });
        } else {
          alert("Error: " + err.message);
        }
        
        throw err;
      }
    }

    function showActionButtons() {
      console.log("Showing action buttons");
      const generateTextButton = document.getElementById('generateTextButton');
      const generateFullTextButton = document.getElementById('generateFullTextButton');
      const generateReportButton = document.getElementById('generateReportButton');
      const outputText = document.getElementById('outputText');
      const copyButton = document.getElementById('copyButton');
      const downloadButton = document.getElementById('downloadButton');
      
      if (generateTextButton && generateFullTextButton && generateReportButton && outputText) {
        generateTextButton.classList.remove('hidden');
        generateFullTextButton.classList.remove('hidden');
        generateReportButton.classList.remove('hidden');
        
        // Show tool tips for action buttons
        if (generateTextButton.getAttribute('data-tooltip') === null) {
          generateTextButton.setAttribute('data-tooltip', 'Generate output only for selected files');
          generateFullTextButton.setAttribute('data-tooltip', 'Generate output for all files but highlight selected ones');
          generateReportButton.setAttribute('data-tooltip', 'Generate a token count report for selected files');
        }
        
        // Initialize tooltips if they exist
        if (typeof tippy !== 'undefined' && typeof window.tippyInstances === 'undefined') {
          setTimeout(() => {
            if (typeof initTooltips === 'function') {
              initTooltips();
            }
          }, 100);
        }
        
        // Reset output area
        outputText.value = '';
        if (copyButton) copyButton.classList.add('hidden');
        if (downloadButton) downloadButton.classList.add('hidden');
      } else {
        console.error("Action button elements missing:", { generateTextButton, generateFullTextButton, generateReportButton, outputText });
      }
    }

    function getSelectedFiles() {
      const selected = Array.from(document.querySelectorAll('#directoryStructure input[type="checkbox"]:checked:not(.folder-checkbox)'))
        .map(cb => JSON.parse(cb.value));
      console.log("Selected files:", selected);
      return selected;
    }

    // Function to load saved GitHub URLs
    async function loadSavedGithubRepos() {
      try {
        const result = await fetchData('/api/get-saved-paths', { type: 'github' });
        if (result.paths && result.paths.length > 0) {
          const dataList = document.getElementById('githubReposList');
          if (dataList) {
            dataList.innerHTML = '';
            result.paths.forEach(path => {
              const option = document.createElement('option');
              option.value = path;
              dataList.appendChild(option);
            });
          }
        }
      } catch (err) {
        console.error("Error loading saved GitHub repositories:", err);
      }
    }
    
    // Function to load saved local paths
    async function loadSavedLocalPaths() {
      try {
        const result = await fetchData('/api/get-saved-paths', { type: 'local' });
        if (result.paths && result.paths.length > 0) {
          const dataList = document.getElementById('localPathsList');
          if (dataList) {
            dataList.innerHTML = '';
            result.paths.forEach(path => {
              const option = document.createElement('option');
              option.value = path;
              dataList.appendChild(option);
            });
          }
        }
      } catch (err) {
        console.error("Error loading saved local paths:", err);
      }
    }
    
    // Apply a saved selection to the UI
    function applySelection(selectionData) {
      if (!selectionData) return;
      
      try {
        // Parse JSON if it's a string
        const selection = typeof selectionData === 'string' ? JSON.parse(selectionData) : selectionData;
        
        if (!Array.isArray(selection)) {
          console.error("Invalid selection format:", selection);
          return;
        }
        
        // Get all checkboxes
        const allCheckboxes = document.querySelectorAll('#directoryStructure input[type="checkbox"]');
        
        // First uncheck all
        allCheckboxes.forEach(cb => {
          cb.checked = false;
          cb.indeterminate = false;
        });
        
        // Then check the ones in the selection
        selection.forEach(path => {
          const cb = document.querySelector(`#directoryStructure input[type="checkbox"][data-path="${path}"]`);
          if (cb) {
            cb.checked = true;
            updateParentCheckbox(cb);
          }
        });
        
        updateExtensionBubbles();
        
        // Show toast with selection count
        if (typeof showToast === 'function') {
          showToast(`Loaded ${selection.length} file(s)`, 'success');
        }
      } catch (err) {
        console.error("Error applying selection:", err);
        
        if (typeof showToast === 'function') {
          showToast("Error applying selection", 'error');
        }
      }
    }

    function displayDirectoryStructure(tree, repoId, lastSelection) {
      console.log("Displaying directory structure with tree:", tree);
      // Store the repo ID 
      currentRepoId = repoId;
      
      const container = document.getElementById('directoryStructure');
      const extContainer = document.getElementById('extBubbleContainer');
      container.innerHTML = '';
      extContainer.innerHTML = '';
      if (!tree.length) {
        container.textContent = 'No files found.';
        return;
      }

      // Pattern matching helper function 
      function matchesPattern(path, pattern) {
        // Convert glob pattern to regex
        const regexPattern = pattern
          .replace(/\./g, '\\.')     // Escape dots
          .replace(/\*/g, '.*')      // Convert * to .*
          .replace(/\?/g, '.');      // Convert ? to .
        
        const regex = new RegExp(`^${regexPattern}$`);
        const filename = path.split('/').pop(); // Get just the filename
        return regex.test(filename);
      }
      
      // Filter files by both extensions and patterns
      const filtered = tree.filter(item => {
        // Check if file matches any extension
        const extensionMatch = ALLOWED_EXTENSIONS.some(ext => 
          item.path.toLowerCase().endsWith(ext)
        );
        
        // Check if file matches any pattern
        const patternMatch = window.FILE_PATTERNS && window.FILE_PATTERNS.some(pattern => 
          matchesPattern(item.path, pattern.extension)
        );
        
        return extensionMatch || patternMatch;
      });
      filtered.sort((a, b) => a.path.localeCompare(b.path));

      const directoryStructure = {};
      const extensionMap = new Map();

      filtered.forEach(item => {
        const pathParts = item.path.split('/').filter(part => part);
        let currentLevel = directoryStructure;
        pathParts.forEach((part, index) => {
          if (!currentLevel[part]) {
            currentLevel[part] = (index === pathParts.length - 1) ? item : {};
          }
          currentLevel = currentLevel[part];
        });

        const ext = item.path.split('.').pop().toLowerCase();
        if (!extensionMap.has(ext)) {
          extensionMap.set(ext, []);
        }
        extensionMap.get(ext).push(item);
      });

      const rootUl = document.createElement('ul');
      rootUl.classList.add('tree-lines');
      container.appendChild(rootUl);

      function createTreeNode(name, item, parentUl, depth = 0) {
        const li = document.createElement('li');
        li.className = 'relative';
        li.style.marginLeft = `${depth * 1}rem`;
        parentUl.appendChild(li);

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'checkbox checkbox-sm mr-2';

        if (typeof item === 'object' && !item.path) {
          // Folder node
          const details = document.createElement('details');
          details.open = false;  // Folders collapsed by default
          const summary = document.createElement('summary');
          summary.className = 'folder-node font-bold flex items-center';
          
          // Add folder icon and name
          summary.innerHTML = `<span class="ml-1 code-folder">${name}</span>`;
          details.appendChild(summary);
          li.appendChild(details);

          const ul = document.createElement('ul');
          ul.classList.add('tree-lines');
          details.appendChild(ul);

          checkbox.classList.add('folder-checkbox');
          li.insertBefore(checkbox, details);

          // Separate folders and files
          const childFolders = [];
          const childFiles = [];
          
          for (const [childName, childItem] of Object.entries(item)) {
            if (typeof childItem === 'object' && !childItem.path) {
              // This is a folder
              childFolders.push([childName, childItem]);
            } else {
              // This is a file
              childFiles.push([childName, childItem]);
            }
          }
          
          // Add folders first
          childFolders.sort((a, b) => a[0].localeCompare(b[0]));
          for (const [childName, childItem] of childFolders) {
            createTreeNode(childName, childItem, ul, depth + 1);
          }
          
          // Then add files
          childFiles.sort((a, b) => a[0].localeCompare(b[0]));
          for (const [childName, childItem] of childFiles) {
            createTreeNode(childName, childItem, ul, depth + 1);
          }

          checkbox.addEventListener('change', () => {
            const childCheckboxes = li.querySelectorAll('input[type="checkbox"]');
            childCheckboxes.forEach(cb => {
              cb.checked = checkbox.checked;
              cb.indeterminate = false;
            });
            updateParentCheckbox(checkbox);
            updateExtensionBubbles();
          });
        } else {
          // File node
          checkbox.value = JSON.stringify(item);
          checkbox.dataset.path = item.path;
          li.appendChild(checkbox);
          
          // Get icon class based on extension
          const ext = name.split('.').pop().toLowerCase();
          const iconClass = `file-${ext}`;
          
          // Create a span with the file name and icon class
          const fileNameSpan = document.createElement('span');
          fileNameSpan.className = `code-file ${iconClass}`;
          fileNameSpan.textContent = ` ${name}`;
          li.appendChild(fileNameSpan);

          extensionMap.get(ext)?.forEach(file => {
            if (file.path === item.path) {
              file.checkbox = checkbox;
            }
          });
        }

        checkbox.addEventListener('change', () => {
          updateParentCheckbox(checkbox);
          updateExtensionBubbles();
        });
      }

      // Separate root folders and files
      const rootFolders = [];
      const rootFiles = [];
      
      for (const [name, item] of Object.entries(directoryStructure)) {
        if (typeof item === 'object' && !item.path) {
          // This is a folder
          rootFolders.push([name, item]);
        } else {
          // This is a file
          rootFiles.push([name, item]);
        }
      }
      
      // Add root folders first
      rootFolders.sort((a, b) => a[0].localeCompare(b[0]));
      for (const [name, item] of rootFolders) {
        createTreeNode(name, item, rootUl);
      }
      
      // Then add root files
      rootFiles.sort((a, b) => a[0].localeCompare(b[0]));
      for (const [name, item] of rootFiles) {
        createTreeNode(name, item, rootUl);
      }

      // "All" bubble
      const allBubble = document.createElement('span');
      allBubble.className = 'ext-bubble selected';
      allBubble.style.backgroundColor = '#555';  
      allBubble.style.color = '#fff';  
      allBubble.id = 'allBubble';
      allBubble.innerHTML = `<i class="fa-solid fa-check-double mr-1"></i> All (${filtered.length})`;
      allBubble.addEventListener('click', () => {
        const isSelected = !allBubble.classList.contains('selected');
        allBubble.classList.toggle('selected', isSelected);
        extContainer.querySelectorAll('.ext-bubble:not(#allBubble)').forEach(bubble => {
          bubble.classList.toggle('selected', isSelected);
          const ext = bubble.dataset.ext;
          extensionMap.get(ext)?.forEach(file => {
            if (file.checkbox) {
              file.checkbox.checked = isSelected;
              updateParentCheckbox(file.checkbox);
            }
          });
        });
      });
      extContainer.appendChild(allBubble);

      // Individual extension bubbles
      extensionMap.forEach((files, ext) => {
        const bubble = document.createElement('span');
        bubble.className = 'ext-bubble selected';
        bubble.style.backgroundColor = EXT_COLORS[ext] || '#555';
        bubble.style.color = '#fff';
        
        // Add file icon based on extension
        const extension = ext.toLowerCase();
        let icon = 'fa-file-code';
        if (extension === 'md' || extension === 'txt') icon = 'fa-file-alt';
        if (extension === 'json' || extension === 'yaml' || extension === 'yml') icon = 'fa-file-alt';
        if (extension === 'html') icon = 'fa-file-code';
        if (extension === 'css') icon = 'fa-file-code';
        if (extension === 'js') icon = 'fa-file-code';
        if (extension === 'py') icon = 'fa-file-code';
        
        bubble.innerHTML = `<i class="fa-solid ${icon} mr-1"></i> .${ext} (${files.length})`;
        bubble.dataset.ext = ext;
        bubble.addEventListener('click', () => {
          const isSelected = !bubble.classList.contains('selected');
          bubble.classList.toggle('selected', isSelected);
          files.forEach(file => {
            if (file.checkbox) {
              file.checkbox.checked = isSelected;
              updateParentCheckbox(file.checkbox);
            }
          });
          updateAllBubble();
        });
        extContainer.appendChild(bubble);
      });

      function updateAllBubble() {
        const allSelected = Array.from(extContainer.querySelectorAll('.ext-bubble:not(#allBubble)'))
          .every(bubble => bubble.classList.contains('selected'));
        allBubble.classList.toggle('selected', allSelected);
      }

      const lineHeight = 24;
      const padding = 32;
      const totalHeight = (filtered.length * lineHeight) + padding;
      container.style.height = `${Math.max(768, totalHeight)}px`;

      container.addEventListener('change', (e) => {
        if (e.target.type === 'checkbox' && !e.target.classList.contains('folder-checkbox')) {
          updateParentCheckbox(e.target);
          updateExtensionBubbles();
        }
      });

      updateExtensionBubbles();
      
      // Make sortable extension bubbles
      if (typeof Sortable !== 'undefined') {
        new Sortable(extContainer, {
          animation: 150,
          ghostClass: 'sorting-ghost',
          onEnd: function(evt) {
            // Optional: Save the new ordering to localStorage
            const newOrder = Array.from(extContainer.children).map(el => 
              el.id === 'allBubble' ? 'all' : el.dataset.ext
            );
            localStorage.setItem('extensionOrder', JSON.stringify(newOrder));
          }
        });
      }
    }

    function updateParentCheckbox(checkbox) {
      const li = checkbox.closest('li');
      if (!li) return;
      const parentLi = li.parentElement.closest('li');
      if (!parentLi) return;
      const parentCheckbox = parentLi.querySelector(':scope > input[type="checkbox"]');
      if (!parentCheckbox) return;

      const siblingCheckboxes = parentLi.querySelectorAll(':scope > ul input[type="checkbox"]');
      const checkedCount = Array.from(siblingCheckboxes).filter(cb => cb.checked).length;
      const totalCount = siblingCheckboxes.length;

      if (checkedCount === 0) {
        parentCheckbox.checked = false;
        parentCheckbox.indeterminate = false;
      } else if (checkedCount === totalCount) {
        parentCheckbox.checked = true;
        parentCheckbox.indeterminate = false;
      } else {
        parentCheckbox.checked = false;
        parentCheckbox.indeterminate = true;
      }
      updateParentCheckbox(parentCheckbox);
    }

    function updateExtensionBubbles() {
      const extContainer = document.getElementById('extBubbleContainer');
      const selectedFiles = getSelectedFiles();
      const selectedExts = new Set(selectedFiles.map(file => file.path.split('.').pop().toLowerCase()));
      extContainer.querySelectorAll('.ext-bubble:not(#allBubble)').forEach(bubble => {
        const ext = bubble.dataset.ext;
        bubble.classList.toggle('selected', selectedExts.has(ext));
      });
      const allBubble = document.getElementById('allBubble');
      if (allBubble) {
        const allSelected = Array.from(extContainer.querySelectorAll('.ext-bubble:not(#allBubble)'))
          .every(bubble => bubble.classList.contains('selected'));
        allBubble.classList.toggle('selected', allSelected);
      }
    }
    
    // Save the current file selection to the database
    async function saveCurrentSelection() {
      const selectedFiles = getSelectedFiles();
      const selection = selectedFiles.map(f => f.path);
      
      try {
        await fetchData('/api/save-selection', {
          repoId: currentRepoId,
          selection: selection
        });
        console.log("Selection saved to database");
      } catch (err) {
        console.error("Error saving selection:", err);
      }
    }

    function formatRepoContents(contents, selected) {
      contents.sort((a, b) => a.path.localeCompare(b.path));
      let output = '# Repository Content\n\n';
      output += '## Directory Structure (Selected Files)\n\n';
      output += contents.map(c => `├── ${c.path}`).join('\n');
      
      output += '\n\n## Files\n';
      output += contents.map(c => `\n### File: ${c.path}\n\`\`\`${getLanguageFromPath(c.path)}\n${c.text}\n\`\`\``).join('\n');

      try {
        if (typeof GPTTokenizer_cl100k_base !== 'undefined') {
          const tokens = GPTTokenizer_cl100k_base.encode(output).length;
          updateTokenCount(output);
        }
      } catch (err) {
        console.error("Token count error or tokenizer not loaded:", err);
      }
      return output;
    }
    
    function formatTokenReport(contents) {
      // Calculate token counts for each file
      const fileTokens = contents.map(file => {
        let tokenCount = 0;
        try {
          if (typeof GPTTokenizer_cl100k_base !== 'undefined') {
            tokenCount = GPTTokenizer_cl100k_base.encode(file.text).length;
          }
        } catch (err) {
          console.error(`Token count error for ${file.path}:`, err);
        }
        return {
          path: file.path,
          tokens: tokenCount
        };
      });
      
      // Sort by token count (descending)
      fileTokens.sort((a, b) => b.tokens - a.tokens);
      
      // Calculate total token count
      const totalTokens = fileTokens.reduce((sum, file) => sum + file.tokens, 0);
      
      // Format the report with directory structure and token table
      let output = '# Token Count Report\n\n';
      
      // Directory structure section
      output += '## Directory Structure (Selected Files)\n\n';
      output += contents.map(c => `├── ${c.path}`).join('\n');
      
      // Token count table
      output += '\n\n## Token Counts by File (Descending)\n\n';
      output += '| File | Token Count | % of Total |\n';
      output += '|------|-------------|------------|\n';
      
      fileTokens.forEach(file => {
        const percentage = totalTokens > 0 ? ((file.tokens / totalTokens) * 100).toFixed(1) : 0;
        output += `| ${file.path} | ${file.tokens.toLocaleString()} | ${percentage}% |\n`;
      });
      
      // Summary
      output += `\n\n## Summary\n\n`;
      output += `- **Total Files:** ${fileTokens.length}\n`;
      output += `- **Total Tokens:** ${totalTokens.toLocaleString()}\n`;
      output += `- **Average Tokens per File:** ${(totalTokens / (fileTokens.length || 1)).toFixed(0).toLocaleString()}\n`;
      
      // Update token counter in UI
      try {
        updateTokenCount(output);
      } catch (err) {
        console.error("Token count error:", err);
      }
      
      return output;
    }
    
    function getLanguageFromPath(path) {
      const ext = path.split('.').pop().toLowerCase();
      return FILE_LANGUAGES[ext] || '';
    }
    
    // Original placeholder for token counting
    window.updateTokenCount = function(text) {
      try {
        if (typeof GPTTokenizer_cl100k_base !== 'undefined') {
          const tokens = GPTTokenizer_cl100k_base.encode(text).length;
          const tokenCount = document.getElementById('tokenCount');
          if (tokenCount) {
            tokenCount.textContent = `${tokens.toLocaleString()} tokens`;
          }
        }
      } catch (err) {
        console.error("Token count error or tokenizer not loaded:", err);
      }
    };
    
    // Token display function removed

    function formatFullRepoContents(contents, selected) {
      contents.sort((a, b) => a.path.localeCompare(b.path));
      const selectedPaths = new Set(selected.map(f => f.path));

      let output = '# Complete Repository Overview\n\n';
      output += '## Full Directory Structure\n\n';
      output += contents.map(c => `${selectedPaths.has(c.path) ? '├──' : '└──'} ${c.path}`).join('\n');

      output += '\n\n## Selected Files\n';
      output += contents
        .filter(c => selectedPaths.has(c.path))
        .map(c => `\n### File: ${c.path}\n\`\`\`${getLanguageFromPath(c.path)}\n${c.text}\n\`\`\``)
        .join('\n');

      try {
        if (typeof GPTTokenizer_cl100k_base !== 'undefined') {
          updateTokenCount(output);
        }
      } catch (err) {
        console.error("Token count error or tokenizer not loaded:", err);
      }
      return output;
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      
      // Show toast notification
      if (typeof showToast === 'function') {
        showToast(`Downloaded ${filename}`, 'success');
      }
    }

    let groupings = [];

    async function loadGroupings() {
      try {
        const result = await fetchData('/api/get-groupings', { repoIdentifier: basePath });
        groupings = result.groupings;
        const select = document.getElementById('groupingSelect');
        select.innerHTML = '<option value="">Select a saved grouping</option>';
        groupings.forEach(g => {
          const option = document.createElement('option');
          option.value = g.name;
          option.textContent = g.name;
          select.appendChild(option);
        });
      } catch (err) {
        if (typeof showToast === 'function') {
          showToast("Error loading groupings: " + err.message, 'error');
        } else {
          alert("Error loading groupings: " + err.message);
        }
      }
    }

    // Event listeners for mode toggles
    const githubTabBtn = document.getElementById('githubTabBtn');
    const localTabBtn = document.getElementById('localTabBtn');
    if (githubTabBtn) {
      githubTabBtn.addEventListener('click', () => {
        toggleMode(true);
        loadSavedGithubRepos(); // Load saved GitHub repos when switching to GitHub mode
      });
    }
    if (localTabBtn) {
      localTabBtn.addEventListener('click', () => {
        toggleMode(false);
        loadSavedLocalPaths(); // Load saved local paths when switching to local mode
      });
    }

    // Load saved paths when the page loads
    loadSavedGithubRepos();
    loadSavedLocalPaths();

    // Fetch GitHub or Local
    const fetchGitHubBtn = document.getElementById('fetchGitHub');
    if (fetchGitHubBtn) {
      fetchGitHubBtn.addEventListener('click', async () => {
        const repoUrl = document.getElementById('repoUrl')?.value.trim();
        if (!repoUrl) {
          if (typeof showToast === 'function') {
            showToast("Please enter a GitHub URL", 'error');
          } else {
            alert("Enter a GitHub URL.");
          }
          return;
        }
        isGithub = true;
        basePath = repoUrl;
        try {
          const data = { repoUrl };
          {% if not has_github_token %}data.accessToken = document.getElementById('accessToken')?.value.trim();{% endif %}
          
          if (typeof showToast === 'function') {
            showToast("Fetching repository data...", 'info');
          }
          
          const result = await fetchData('/api/github-tree', data);
          currentTree = result.tree;
          currentRepoId = result.repoId;
          displayDirectoryStructure(currentTree, currentRepoId, null);
          showActionButtons();
          
          // Show success toast
          if (typeof showToast === 'function') {
            showToast(`Fetched ${result.tree.length} files from GitHub repository`, 'success');
          }
        } catch (err) {
          if (typeof showToast === 'function') {
            showToast("Error: " + err.message, 'error');
          } else {
            alert("Error: " + err.message);
          }
        }
      });
    }

    const fetchLocalBtn = document.getElementById('fetchLocal');
    if (fetchLocalBtn) {
      fetchLocalBtn.addEventListener('click', async () => {
        const localPath = document.getElementById('localPath')?.value.trim();
        if (!localPath) {
          if (typeof showToast === 'function') {
            showToast("Please enter a local file path", 'error');
          } else {
            alert("Enter a local path.");
          }
          return;
        }
        isGithub = false;
        basePath = localPath;
        try {
          if (typeof showToast === 'function') {
            showToast("Scanning local directory...", 'info');
          }
          
          const result = await fetchData('/api/local-tree', { localPath });
          currentTree = result.tree;
          currentRepoId = result.repoId;
          displayDirectoryStructure(currentTree, currentRepoId, null);
          showActionButtons();
          
          // Show success toast
          if (typeof showToast === 'function') {
            showToast(`Scanned ${result.tree.length} files from local directory`, 'success');
          }
        } catch (err) {
          if (typeof showToast === 'function') {
            showToast("Error: " + err.message, 'error');
          } else {
            alert("Error: " + err.message);
          }
        }
      });
    }

    // Generate text from selected files
    document.getElementById('generateTextButton').addEventListener('click', async () => {
      const selected = getSelectedFiles();
      if (!selected.length) {
        if (typeof showToast === 'function') {
          showToast("Please select at least one file", 'warning');
        } else {
          alert("No files selected.");
        }
        return;
      }
      
      const data = { repoIdentifier: basePath, filePaths: selected.map(f => f.path) };
      {% if not has_github_token %} if (isGithub) data.accessToken = document.getElementById('accessToken')?.value.trim(); {% endif %}
      
      try {
        if (typeof showToast === 'function') {
          showToast(`Generating output for ${selected.length} selected files...`, 'info');
        }
        
        const contents = await fetchData('/api/file-contents', data, true);
        const outputText = document.getElementById('outputText');
        outputText.value = formatRepoContents(contents, selected);
        document.getElementById('copyButton').classList.remove('hidden');
        document.getElementById('downloadButton').classList.remove('hidden');
        
        // Hide the empty state overlay
        const emptyStateOverlay = document.getElementById('emptyStateOverlay');
        if (emptyStateOverlay) {
          emptyStateOverlay.style.opacity = '0';
        }
        
        // Show success message and celebrate
        if (typeof showToast === 'function') {
          showToast("Output generated successfully!", 'success');
        }
        
        if (typeof showCelebration === 'function') {
          showCelebration(1500);
        }
      } catch (err) {
        if (typeof showToast === 'function') {
          showToast("Error: " + err.message, 'error');
        } else {
          alert("Error: " + err.message);
        }
      }
    });

    // Generate text for *all* files, marking selected separately
    document.getElementById('generateFullTextButton').addEventListener('click', async () => {
      const selected = getSelectedFiles();
      if (!selected.length) {
        if (typeof showToast === 'function') {
          showToast("Please select at least one file to highlight", 'warning');
        }
      }
      
      const allFilePaths = currentTree.filter(f => ALLOWED_EXTENSIONS.some(ext => f.path.toLowerCase().endsWith(ext))).map(f => f.path);
      const data = { repoIdentifier: basePath, filePaths: allFilePaths };
      {% if not has_github_token %} if (isGithub) data.accessToken = document.getElementById('accessToken')?.value.trim(); {% endif %}
      
      try {
        if (typeof showToast === 'function') {
          showToast(`Generating full project output (${allFilePaths.length} files)...`, 'info');
        }
        
        // Use a try-catch with a timeout to handle potential server timeouts
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error("Request timed out. The project might be too large to process at once.")), 60000);
        });
        
        const contents = await Promise.race([
          fetchData('/api/file-contents', data, true),
          timeoutPromise
        ]);
        
        const outputText = document.getElementById('outputText');
        outputText.value = formatFullRepoContents(contents, selected);
        document.getElementById('copyButton').classList.remove('hidden');
        document.getElementById('downloadButton').classList.remove('hidden');
        
        // Hide the empty state overlay
        const emptyStateOverlay = document.getElementById('emptyStateOverlay');
        if (emptyStateOverlay) {
          emptyStateOverlay.style.opacity = '0';
        }
        
        // Show success message
        if (typeof showToast === 'function') {
          showToast("Full project output generated!", 'success');
        }
        
        if (typeof showCelebration === 'function') {
          showCelebration(1500);
        }
      } catch (err) {
        if (typeof showToast === 'function') {
          showToast("Error: " + err.message, 'error');
        } else {
          alert("Error: " + err.message);
        }
        
        // Clear any existing progress indicators
        if (progressContainerBottom) {
          progressContainerBottom.classList.add('hidden');
        }
      }
    });
    
    // Generate token report for selected files
    document.getElementById('generateReportButton').addEventListener('click', async () => {
      const selected = getSelectedFiles();
      if (!selected.length) {
        if (typeof showToast === 'function') {
          showToast("Please select at least one file for the report", 'warning');
        } else {
          alert("No files selected for the report.");
        }
        return;
      }
      
      const data = { repoIdentifier: basePath, filePaths: selected.map(f => f.path) };
      {% if not has_github_token %} if (isGithub) data.accessToken = document.getElementById('accessToken')?.value.trim(); {% endif %}
      
      try {
        if (typeof showToast === 'function') {
          showToast(`Generating token report for ${selected.length} files...`, 'info');
        }
        
        const contents = await fetchData('/api/file-contents', data, true);
        const outputText = document.getElementById('outputText');
        outputText.value = formatTokenReport(contents);
        document.getElementById('copyButton').classList.remove('hidden');
        document.getElementById('downloadButton').classList.remove('hidden');
        
        // Hide the empty state overlay
        const emptyStateOverlay = document.getElementById('emptyStateOverlay');
        if (emptyStateOverlay) {
          emptyStateOverlay.style.opacity = '0';
        }
        
        // Show success message
        if (typeof showToast === 'function') {
          showToast("Token report generated successfully!", 'success');
        }
      } catch (err) {
        if (typeof showToast === 'function') {
          showToast("Error: " + err.message, 'error');
        } else {
          alert("Error: " + err.message);
        }
      }
    });

    // Copy to clipboard
    document.getElementById('copyButton').addEventListener('click', () => {
      const text = document.getElementById('outputText').value;
      navigator.clipboard.writeText(text).then(() => {
        if (typeof showToast === 'function') {
          showToast("Copied to clipboard!", 'success');
        } else {
          const toast = document.createElement('div');
          toast.className = 'toast toast-end';
          toast.innerHTML = `
            <div class="alert alert-success">
              <i class="fa-solid fa-check-circle"></i>
              <span>Copied to clipboard!</span>
            </div>
          `;
          document.body.appendChild(toast);
          setTimeout(() => {
            toast.remove();
          }, 2000);
        }
      });
    });

    // Download
    document.getElementById('downloadButton').addEventListener('click', () => {
      const text = document.getElementById('outputText').value;
      if (!text.trim()) {
        if (typeof showToast === 'function') {
          showToast("No content to download", 'warning');
        } else {
          alert("No content to download.");
        }
        return;
      }
      
      // Get current timestamp for filename
      const now = new Date();
      const timestamp = `${now.getFullYear()}-${(now.getMonth()+1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}-${now.getMinutes().toString().padStart(2, '0')}`;
      
      downloadBlob(new Blob([text], { type: 'text/plain' }), `code_export_${timestamp}.md`);
    });

    // Groupings
    document.getElementById('saveGrouping').addEventListener('click', async () => {
      const groupingName = document.getElementById('groupingName').value.trim();
      const selected = getSelectedFiles();
      
      if (!groupingName) {
        if (typeof showToast === 'function') {
          showToast("Please enter a grouping name", 'warning');
        } else {
          alert("Enter a grouping name.");
        }
        return;
      }
      
      if (!selected.length) {
        if (typeof showToast === 'function') {
          showToast("Please select files to save in this grouping", 'warning');
        } else {
          alert("No files selected to save in grouping.");
        }
        return;
      }
      
      const data = { repoIdentifier: basePath, groupingName, filePaths: selected.map(f => f.path) };
      
      try {
        const result = await fetchData('/api/save-grouping', data);
        
        if (typeof showToast === 'function') {
          showToast(`Grouping "${groupingName}" saved with ${selected.length} files`, 'success');
        } else {
          alert(result.message);
        }
        
        await loadGroupings();
        
        // Clear the grouping name input after saving
        document.getElementById('groupingName').value = '';
      } catch (err) {
        if (typeof showToast === 'function') {
          showToast("Error saving grouping: " + err.message, 'error');
        } else {
          alert("Error saving grouping: " + err.message);
        }
      }
    });

    document.getElementById('loadGrouping').addEventListener('click', () => {
      const selectedName = document.getElementById('groupingSelect').value;
      if (!selectedName) {
        if (typeof showToast === 'function') {
          showToast("Please select a grouping to load", 'warning');
        } else {
          alert("Please select a grouping to load.");
        }
        return;
      }

      const allCheckboxes = document.querySelectorAll('#directoryStructure input[type="checkbox"]');
      allCheckboxes.forEach(cb => {
        cb.checked = false;
        cb.indeterminate = false;
      });

      const grouping = groupings.find(g => g.name === selectedName);
      if (grouping && grouping.files.length) {
        grouping.files.forEach(file => {
          const cb = document.querySelector(`#directoryStructure input[type="checkbox"][data-path="${file.path}"]`);
          if (cb) {
            cb.checked = true;
            updateParentCheckbox(cb);
          }
        });
        updateExtensionBubbles();
        
        if (typeof showToast === 'function') {
          showToast(`Loaded grouping "${selectedName}" with ${grouping.files.length} files`, 'success');
        }
      } else {
        if (typeof showToast === 'function') {
          showToast("No files found in this grouping", 'error');
        } else {
          alert("No files found in this grouping or grouping not loaded correctly.");
        }
      }
    });
    
    // Attach data-tooltip attributes to various elements for tooltips
    function setupTooltips() {
      const tooltipData = [
        { selector: '#expandAllBtn', tooltip: 'Expand all folders' },
        { selector: '#collapseAllBtn', tooltip: 'Collapse all folders' },
        { selector: '#clearSearchBtn', tooltip: 'Clear search' },
        { selector: '#treeSearchInput', tooltip: 'Search files by name' },
        { selector: '#saveGrouping', tooltip: 'Save current selection as a named grouping' },
        { selector: '#loadGrouping', tooltip: 'Load a saved selection grouping' },
        { selector: '#expandButton', tooltip: 'Toggle fullscreen view' },
        { selector: '#copyButton', tooltip: 'Copy output to clipboard' },
        { selector: '#downloadButton', tooltip: 'Download output as file' },
        { selector: '#allBubble', tooltip: 'Select or deselect all file types' },
        { selector: '#generateReportButton', tooltip: 'Generate a token count report for selected files' }
      ];
      
      tooltipData.forEach(item => {
        const element = document.querySelector(item.selector);
        if (element && !element.hasAttribute('data-tooltip')) {
          element.setAttribute('data-tooltip', item.tooltip);
        }
      });
    }
    
    // Initialize tooltips when DOM is loaded
    setTimeout(setupTooltips, 500);
  });
</script>
<script src="https://unpkg.com/gpt-tokenizer"></script>